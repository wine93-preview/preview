/* Code generated by cmd/cgo; DO NOT EDIT. */

/* package command-line-arguments */


#line 1 "cgo-builtin-export-prolog"

#include <stddef.h> /* for ptrdiff_t below */

#ifndef GO_CGO_EXPORT_PROLOGUE_H
#define GO_CGO_EXPORT_PROLOGUE_H

#ifndef GO_CGO_GOSTRING_TYPEDEF
typedef struct { const char *p; ptrdiff_t n; } _GoString_;
#endif

#endif

/* Start of preamble from import "C" comments.  */


#line 19 "etcdclient.go"

#include <stdlib.h>

enum EtcdErrCode
{
    // grpc errCode, 具体的含义见:
    // https://godoc.org/go.etcd.io/etcd/etcdserver/api/v3rpc/rpctypes#ErrGRPCNoSpace
    // https://godoc.org/google.golang.org/grpc/codes#Code
    EtcdOK = 0,
    EtcdCanceled = 1,
    EtcdUnknown = 2,
    EtcdInvalidArgument = 3,
    EtcdDeadlineExceeded = 4,
    EtcdNotFound = 5,
    EtcdAlreadyExists = 6,
    EtcdPermissionDenied = 7,
    EtcdResourceExhausted = 8,
    EtcdFailedPrecondition = 9,
    EtcdAborted = 10,
    EtcdOutOfRange = 11,
    EtcdUnimplemented = 12,
    EtcdInternal = 13,
    EtcdUnavailable = 14,
    EtcdDataLoss = 15,
    EtcdUnauthenticated = 16,

    // 自定义错误码
    EtcdTxnUnkownOp = 17,
    EtcdObjectNotExist = 18,
    EtcdErrObjectType = 19,
    EtcdKeyNotExist = 20,
    EtcdCampaignInternalErr = 21,
    EtcdCampaignLeaderSuccess = 22,
    EtcdObserverLeaderInternal = 23,
    EtcdObserverLeaderChange = 24,
    EtcdLeaderResignErr = 25,
    EtcdLeaderResiginSuccess = 26,
    EtcdGetLeaderKeyErr = 27,
    EtcdGetLeaderKeyOK = 28,
    EtcdObserverLeaderNotExist = 29,
    EtcdObjectLenNotEnough = 30,
};

enum OpType {
  OpPut = 1,
  OpDelete = 2
};

struct EtcdConf {
    char *Endpoints;
    int len;
    int DialTimeout;
};

struct Operation {
    enum OpType opType;
    char *key;
    char *value;
    int keyLen;
    int valueLen;
};

#line 1 "cgo-generated-wrapper"


/* End of preamble from import "C" comments.  */


/* Start of boilerplate cgo prologue.  */
#line 1 "cgo-gcc-export-header-prolog"

#ifndef GO_CGO_PROLOGUE_H
#define GO_CGO_PROLOGUE_H

typedef signed char GoInt8;
typedef unsigned char GoUint8;
typedef short GoInt16;
typedef unsigned short GoUint16;
typedef int GoInt32;
typedef unsigned int GoUint32;
typedef long long GoInt64;
typedef unsigned long long GoUint64;
typedef GoInt64 GoInt;
typedef GoUint64 GoUint;
typedef __SIZE_TYPE__ GoUintptr;
typedef float GoFloat32;
typedef double GoFloat64;
typedef float _Complex GoComplex64;
typedef double _Complex GoComplex128;

/*
  static assertion to make sure the file is being used on architecture
  at least with matching size of GoInt.
*/
typedef char _check_for_64_bit_pointer_matching_GoInt[sizeof(void*)==64/8 ? 1:-1];

#ifndef GO_CGO_GOSTRING_TYPEDEF
typedef _GoString_ GoString;
#endif
typedef void *GoMap;
typedef void *GoChan;
typedef struct { void *t; void *v; } GoInterface;
typedef struct { void *data; GoInt len; GoInt cap; } GoSlice;

#endif

/* End of boilerplate cgo prologue.  */

#ifdef __cplusplus
extern "C" {
#endif


// TODO(lixiaocui): 日志打印看是否需要glog
extern enum EtcdErrCode NewEtcdClientV3(struct EtcdConf conf);
extern void EtcdCloseClient();
extern enum EtcdErrCode EtcdClientPut(int timeout, char* key, char* value, int keyLen, int valueLen);

/* Return type for EtcdClientPutRewtihRevision */
struct EtcdClientPutRewtihRevision_return {
	enum EtcdErrCode r0;
	GoInt64 r1;
};
extern struct EtcdClientPutRewtihRevision_return EtcdClientPutRewtihRevision(int timeout, char* key, char* value, int keyLen, int valueLen);

/* Return type for EtcdClientGet */
struct EtcdClientGet_return {
	enum EtcdErrCode r0;
	char* r1;
	GoInt r2;
	GoInt64 r3;
};
extern struct EtcdClientGet_return EtcdClientGet(int timeout, char* key, int keyLen);

/* Return type for EtcdClientList */
struct EtcdClientList_return {
	enum EtcdErrCode r0;
	GoUint64 r1;
	GoInt64 r2;
};

// TODO(lixiaocui): list可能需要有长度限制
extern struct EtcdClientList_return EtcdClientList(int timeout, char* startKey, char* endKey, int startLen, int endLen);

/* Return type for EtcdClientListWithLimitAndRevision */
struct EtcdClientListWithLimitAndRevision_return {
	enum EtcdErrCode r0;
	GoUint64 r1;
	GoInt r2;
	GoInt64 r3;
};
extern struct EtcdClientListWithLimitAndRevision_return EtcdClientListWithLimitAndRevision(unsigned int timeout, char* startKey, char* endKey, int startLen, int endLen, GoInt64 limit, GoInt64 startRevision);
extern enum EtcdErrCode EtcdClientDelete(int timeout, char* key, int keyLen);

/* Return type for EtcdClientDeleteRewithRevision */
struct EtcdClientDeleteRewithRevision_return {
	enum EtcdErrCode r0;
	GoInt64 r1;
};
extern struct EtcdClientDeleteRewithRevision_return EtcdClientDeleteRewithRevision(int timeout, char* key, int keyLen);
extern enum EtcdErrCode EtcdClientTxn2(int timeout, struct Operation op1, struct Operation op2);
extern enum EtcdErrCode EtcdClientTxn3(int timeout, struct Operation op1, struct Operation op2, struct Operation op3);
extern enum EtcdErrCode EtcdClientCompareAndSwap(int timeout, char* key, char* prev, char* target, int keyLen, int preLen, int targetLen);

/* Return type for EtcdElectionCampaign */
struct EtcdElectionCampaign_return {
	enum EtcdErrCode r0;
	GoUint64 r1;
};
extern struct EtcdElectionCampaign_return EtcdElectionCampaign(char* pfx, int pfxLen, char* leaderName, int nameLen, GoUint32 sessionInterSec, GoUint32 electionTimeoutMs);
extern enum EtcdErrCode EtcdLeaderObserve(GoUint64 leaderOid, char* leaderName, int nameLen);
extern enum EtcdErrCode EtcdLeaderResign(GoUint64 leaderOid, GoUint64 timeout);

/* Return type for EtcdClientGetSingleObject */
struct EtcdClientGetSingleObject_return {
	enum EtcdErrCode r0;
	char* r1;
	GoInt r2;
};
extern struct EtcdClientGetSingleObject_return EtcdClientGetSingleObject(GoUint64 oid);

/* Return type for EtcdClientGetMultiObject */
struct EtcdClientGetMultiObject_return {
	enum EtcdErrCode r0;
	char* r1;
	GoInt r2;
	char* r3;
	GoInt r4;
};
extern struct EtcdClientGetMultiObject_return EtcdClientGetMultiObject(GoUint64 oid, GoInt serial);
extern void EtcdClientRemoveObject(GoUint64 oid);
extern int64_t NewEtcdMutex(char* pfx, int pfxLen, GoInt ttl);
extern enum EtcdErrCode EtcdMutexLock(int timeout, int64_t id);
extern enum EtcdErrCode EtcdMutexUnlock(int timeout, int64_t id);
extern void DestoryEtcdMutex(int64_t id);

#ifdef __cplusplus
}
#endif
